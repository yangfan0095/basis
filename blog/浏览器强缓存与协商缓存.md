#### 浏览器强缓存

* 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，
包括缓存header信息；本次请求根本就不会与服务器进行通信；

* 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match）
，由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，
它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容

##### 强缓存 header
* expires  这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串
* cache-control：max-age=number 这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，
如果请求时间在过期时间之前，就能命中缓存，否则就不行；

#### 协商缓存
* Last-Modified/If-Modified-Since  通过标记资源修改时间 来判断是否满足协商缓存
* Etag/If-None-Match 服务器生成的每个资源的唯一标识字符串 来判断是否满足协商缓存

##### Etag 优先级更高  ，其出现是为了解决一些 last-modified 存在的问题如：

* 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
* 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
* 某些服务器不能精确的得到文件的最后修改时间。

Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。



